import User from "../models/User.js";
import jwt from "jsonwebtoken";

// Middleware to protect routes

export const protectRoute = async (req, res, next) => {
  try {
    // 1. Получение токена из заголовков запроса
    const token = req.headers.token;
    // 2. Верификация токена
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    // 3. Поиск пользователя в базе данных
    const user = await User.findById(decoded.userId).select("-password");
    // 4. Проверка существования пользователя
    if (!user) return res.json({ success: false, message: "User not found" });
    // 5. Добавление пользователя в объект запроса
    req.user = user;
    // 6. Передача управления следующему middleware/контроллеру
    next();
  } catch (error) {
    console.log(error.message);
    res.json({ success: false, message: error.message });
  }
};

//Controller to check if user is authenticated
export const checkAuth = (req, res) => {
  res.json({ success: true, user: req.user });
};

/* Подробный процесс работы middleware:
Извлечение токена:

Токен извлекается из заголовка token входящего HTTP-запроса

Ожидается формат: headers: { token: "ваш.jwt.токен" }

Верификация токена:

Используется метод jwt.verify() для проверки подлинности токена

Токен проверяется с использованием секретного ключа из переменных окружения (process.env.JWT_SECRET)

Если токен невалиден (истёк, подделан и т.д.), будет выброшено исключение

Поиск пользователя:

Из декодированного токена извлекается userId

Пользователь ищется в базе данных по этому ID

Метод .select("-password") исключает поле password из результатов

Проверка пользователя:

Если пользователь не найден, возвращается ошибка

Это важно на случай, если пользователь был удалён, но токен ещё валиден

Добавление пользователя в запрос:

Найденный пользователь добавляется в объект запроса (req.user)

Это позволяет последующим middleware/контроллерам иметь доступ к данным пользователя

Передача управления:

Вызов next() передаёт управление следующему middleware в цепочке

Обработка ошибок:
Все ошибки (невалидный токен, проблемы с базой данных и т.д.) перехватываются

Клиенту возвращается JSON с success: false и сообщением об ошибке

Ошибка также логируется в консоль

2. Контроллер проверки аутентификации (checkAuth)
javascript
export const checkAuth = (req, res) => {
  res.json({ success: true, user: req.user });
};
Как это работает:
Этот контроллер должен использоваться после protectRoute

Он просто возвращает данные пользователя, которые были добавлены в req.user middleware protectRoute

Формат ответа:

json
{
  "success": true,
  "user": {  данные пользователя без пароля  }
}
Особенности безопасности:
Защита пароля: Пароль исключается из результатов запроса к базе данных

Валидация токена: Используется стандартная библиотека jwt для проверки токенов

Переменные окружения: Секретный ключ берётся из process.env, что правильно для безопасности

Обработка ошибок: Все возможные ошибки корректно обрабатываются

Пример использования в маршрутах:
Обычно такие middleware используются так:

javascript
import { protectRoute, checkAuth } from './path/to/this/file';

// Защищённый маршрут
router.get('/profile', protectRoute, (req, res) => {
  // Доступно req.user
});

// Проверка аутентификации
router.get('/check-auth', protectRoute, checkAuth);
Возможные улучшения:
Более строгая проверка заголовков: Можно проверять наличие префикса "Bearer " в заголовке Authorization

Обновление токенов: Реализовать механизм refresh-токенов

Детализация ошибок: Разные сообщения для "токен истёк", "токен невалиден" и т.д.

Логирование: Более сложная система логирования ошибок аутентификации

Этот код представляет собой стандартную, но эффективную реализацию защиты маршрутов с помощью JWT в Node.js-приложении. */
